
(function(a,b){if(typeof define==="function"&&define.amd){define([],b);}else{if(typeof exports==="object"){module.exports=b();}else{a.X2JS=b();}}}(this,function(){return function(z){var t="1.2.0";z=z||{};i();u();function i(){if(z.escapeMode===undefined){z.escapeMode=true;}z.attributePrefix=z.attributePrefix||"_";z.arrayAccessForm=z.arrayAccessForm||"none";z.emptyNodeForm=z.emptyNodeForm||"text";if(z.enableToStringFunc===undefined){z.enableToStringFunc=true;}z.arrayAccessFormPaths=z.arrayAccessFormPaths||[];if(z.skipEmptyTextNodesForObj===undefined){z.skipEmptyTextNodesForObj=true;}if(z.stripWhitespaces===undefined){z.stripWhitespaces=true;}z.datetimeAccessFormPaths=z.datetimeAccessFormPaths||[];if(z.useDoubleQuotes===undefined){z.useDoubleQuotes=false;}z.xmlElementsFilter=z.xmlElementsFilter||[];z.jsonPropertiesFilter=z.jsonPropertiesFilter||[];if(z.keepCData===undefined){z.keepCData=false;}}var h={ELEMENT_NODE:1,TEXT_NODE:3,CDATA_SECTION_NODE:4,COMMENT_NODE:8,DOCUMENT_NODE:9};function u(){}function x(B){var C=B.localName;if(C==null){C=B.baseName;}if(C==null||C==""){C=B.nodeName;}return C;}function r(B){return B.prefix;}function s(B){if(typeof(B)=="string"){return B.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&apos;");}else{return B;}}function k(B){return B.replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&quot;/g,'"').replace(/&apos;/g,"'").replace(/&amp;/g,"&");}function w(C,F,D,E){var B=0;for(;B<C.length;B++){var G=C[B];if(typeof G==="string"){if(G==E){break;}}else{if(G instanceof RegExp){if(G.test(E)){break;}}else{if(typeof G==="function"){if(G(F,D,E)){break;}}}}}return B!=C.length;}function n(D,B,C){switch(z.arrayAccessForm){case"property":if(!(D[B] instanceof Array)){D[B+"_asArray"]=[D[B]];}else{D[B+"_asArray"]=D[B];}break;}if(!(D[B] instanceof Array)&&z.arrayAccessFormPaths.length>0){if(w(z.arrayAccessFormPaths,D,B,C)){D[B]=[D[B]];}}}function a(G){var E=G.split(/[-T:+Z]/g);var F=new Date(E[0],E[1]-1,E[2]);var D=E[5].split(".");F.setHours(E[3],E[4],D[0]);if(D.length>1){F.setMilliseconds(D[1]);}if(E[6]&&E[7]){var C=E[6]*60+Number(E[7]);var B=/\d\d-\d\d:\d\d$/.test(G)?"-":"+";C=0+(B=="-"?-1*C:C);F.setMinutes(F.getMinutes()-C-F.getTimezoneOffset());}else{if(G.indexOf("Z",G.length-1)!==-1){F=new Date(Date.UTC(F.getFullYear(),F.getMonth(),F.getDate(),F.getHours(),F.getMinutes(),F.getSeconds(),F.getMilliseconds()));}}return F;}function q(D,B,C){if(z.datetimeAccessFormPaths.length>0){var E=C.split(".#")[0];if(w(z.datetimeAccessFormPaths,D,B,E)){return a(D);}else{return D;}}else{return D;}}function b(E,C,B,D){if(C==h.ELEMENT_NODE&&z.xmlElementsFilter.length>0){return w(z.xmlElementsFilter,E,B,D);}else{return true;}}function A(D,J){if(D.nodeType==h.DOCUMENT_NODE){var K=new Object;var B=D.childNodes;for(var L=0;L<B.length;L++){var C=B.item(L);if(C.nodeType==h.ELEMENT_NODE){var I=x(C);K[I]=A(C,I);}}return K;}else{if(D.nodeType==h.ELEMENT_NODE){var K=new Object;K.__cnt=0;var B=D.childNodes;for(var L=0;L<B.length;L++){var C=B.item(L);var I=x(C);if(C.nodeType!=h.COMMENT_NODE){var H=J+"."+I;if(b(K,C.nodeType,I,H)){K.__cnt++;if(K[I]==null){K[I]=A(C,H);n(K,I,H);}else{if(K[I]!=null){if(!(K[I] instanceof Array)){K[I]=[K[I]];n(K,I,H);}}(K[I])[K[I].length]=A(C,H);}}}}for(var E=0;E<D.attributes.length;E++){var F=D.attributes.item(E);K.__cnt++;K[z.attributePrefix+F.name]=F.value;}var G=r(D);if(G!=null&&G!=""){K.__cnt++;K.__prefix=G;}if(K["#text"]!=null){K.__text=K["#text"];if(K.__text instanceof Array){K.__text=K.__text.join("\n");}if(z.stripWhitespaces){K.__text=K.__text.trim();}delete K["#text"];if(z.arrayAccessForm=="property"){delete K["#text_asArray"];}K.__text=q(K.__text,I,J+"."+I);}if(K["#cdata-section"]!=null){K.__cdata=K["#cdata-section"];delete K["#cdata-section"];if(z.arrayAccessForm=="property"){delete K["#cdata-section_asArray"];}}if(K.__cnt==0&&z.emptyNodeForm=="text"){K="";}else{if(K.__cnt==1&&K.__text!=null){K=K.__text;}else{if(K.__cnt==1&&K.__cdata!=null&&!z.keepCData){K=K.__cdata;}else{if(K.__cnt>1&&K.__text!=null&&z.skipEmptyTextNodesForObj){if((z.stripWhitespaces&&K.__text=="")||(K.__text.trim()=="")){delete K.__text;}}}}}delete K.__cnt;if(z.enableToStringFunc&&(K.__text!=null||K.__cdata!=null)){K.toString=function(){return(this.__text!=null?this.__text:"")+(this.__cdata!=null?this.__cdata:"");};}return K;}else{if(D.nodeType==h.TEXT_NODE||D.nodeType==h.CDATA_SECTION_NODE){return D.nodeValue;}}}}function o(I,F,H,C){var E="<"+((I!=null&&I.__prefix!=null)?(I.__prefix+":"):"")+F;if(H!=null){for(var G=0;G<H.length;G++){var D=H[G];var B=I[D];if(z.escapeMode){B=s(B);}E+=" "+D.substr(z.attributePrefix.length)+"=";if(z.useDoubleQuotes){E+='"'+B+'"';}else{E+="'"+B+"'";}}}if(!C){E+=">";}else{E+="/>";}return E;}function j(C,B){return"</"+(C.__prefix!=null?(C.__prefix+":"):"")+B+">";}function v(C,B){return C.indexOf(B,C.length-B.length)!==-1;}function y(C,B){if((z.arrayAccessForm=="property"&&v(B.toString(),("_asArray")))||B.toString().indexOf(z.attributePrefix)==0||B.toString().indexOf("__")==0||(C[B] instanceof Function)){return true;}else{return false;}}function m(D){var C=0;if(D instanceof Object){for(var B in D){if(y(D,B)){continue;}C++;}}return C;}function l(D,B,C){return z.jsonPropertiesFilter.length==0||C==""||w(z.jsonPropertiesFilter,D,B,C);}function c(D){var C=[];if(D instanceof Object){for(var B in D){if(B.toString().indexOf("__")==-1&&B.toString().indexOf(z.attributePrefix)==0){C.push(B);}}}return C;}function g(C){var B="";if(C.__cdata!=null){B+="<![CDATA["+C.__cdata+"]]>";}if(C.__text!=null){if(z.escapeMode){B+=s(C.__text);}else{B+=C.__text;}}return B;}function d(C){var B="";if(C instanceof Object){B+=g(C);}else{if(C!=null){if(z.escapeMode){B+=s(C);}else{B+=C;}}}return B;}function p(C,B){if(C===""){return B;}else{return C+"."+B;}}function f(D,G,F,E){var B="";if(D.length==0){B+=o(D,G,F,true);}else{for(var C=0;C<D.length;C++){B+=o(D[C],G,c(D[C]),false);B+=e(D[C],p(E,G));B+=j(D[C],G);}}return B;}function e(I,H){var B="";var F=m(I);if(F>0){for(var E in I){if(y(I,E)||(H!=""&&!l(I,E,p(H,E)))){continue;}var D=I[E];var G=c(D);if(D==null||D==undefined){B+=o(D,E,G,true);}else{if(D instanceof Object){if(D instanceof Array){B+=f(D,E,G,H);}else{if(D instanceof Date){B+=o(D,E,G,false);B+=D.toISOString();B+=j(D,E);}else{var C=m(D);if(C>0||D.__text!=null||D.__cdata!=null){B+=o(D,E,G,false);B+=e(D,p(H,E));B+=j(D,E);}else{B+=o(D,E,G,true);}}}}else{B+=o(D,E,G,false);B+=d(D);B+=j(D,E);}}}}B+=d(I);return B;}this.parseXmlString=function(D){var F=window.ActiveXObject||"ActiveXObject" in window;if(D===undefined){return null;}var E;if(window.DOMParser){var G=new window.DOMParser();var B=null;if(!F){try{B=G.parseFromString("INVALID","text/xml").getElementsByTagName("parsererror")[0].namespaceURI;}catch(C){B=null;}}try{E=G.parseFromString(D,"text/xml");if(B!=null&&E.getElementsByTagNameNS(B,"parsererror").length>0){E=null;}}catch(C){E=null;}}else{if(D.indexOf("<?")==0){D=D.substr(D.indexOf("?>")+2);}E=new ActiveXObject("Microsoft.XMLDOM");E.async="false";E.loadXML(D);}return E;};this.asArray=function(B){if(B===undefined||B==null){return[];}else{if(B instanceof Array){return B;}else{return[B];}}};this.toXmlDateTime=function(B){if(B instanceof Date){return B.toISOString();}else{if(typeof(B)==="number"){return new Date(B).toISOString();}else{return null;}}};this.asDateTime=function(B){if(typeof(B)=="string"){return a(B);}else{return B;}};this.xml2json=function(B){return A(B);};this.xml_str2json=function(B){var C=this.parseXmlString(B);if(C!=null){return this.xml2json(C);}else{return null;}};this.json2xml_str=function(B){return e(B,"");};this.json2xml=function(C){var B=this.json2xml_str(C);return this.parseXmlString(B);};this.getVersion=function(){return t;};};}));
(function() {	
    angular.module('myApp', ['mainform','logtable','ngAnimate'])
	//add cookies back in ,'ngCookies'
	
	.run(["$http", "$rootScope", function($http,$rootScope) {		
        $rootScope.authenticated = true;
        $rootScope.authToken = "test";
		$rootScope.startField = "test";		
		
		$rootScope.getLocation = function(){
			return 'title'
		}
		$rootScope.doReset = function () {
	        $rootScope.data = new Array();
	    }		
	}])
	
	.config(["$httpProvider", function ($httpProvider) {
		// passthru auth
	    $httpProvider.defaults.withCredentials = true;
	}])
	
	.directive('elastic', [
	    '$timeout',
	    function($timeout) {
	        return {
	            restrict: 'A',
	            link: function($scope, element) {
	                $scope.initialHeight = $scope.initialHeight || element[0].style.height;
	                var resize = function() {
	                    element[0].style.height = $scope.initialHeight;
	                    element[0].style.height = "" + element[0].scrollHeight + "px";
	                };
	                element.on("input change", resize);
	                $timeout(resize, 0);
	            }
	        };
	    }
	]);
})();
/*
ngprogress 1.1.2 - slim, site-wide progressbar for AngularJS 
(C) 2013 - Victor Bjelkholm 
License: MIT 
Source: https://github.com/VictorBjelkholm/ngProgress 
Date Compiled: 2015-07-27 
*/
angular.module('ngProgress.provider', ['ngProgress.directive'])
    .service('ngProgress', function () {
        'use strict';
				return ['$document', '$window', '$compile', '$rootScope', '$timeout', function($document, $window, $compile, $rootScope, $timeout) {
						this.autoStyle = true;
						this.count = 0;
            this.height = '2px';
						this.$scope = $rootScope.$new();
						this.color = '#0ED0FF';
						this.parent = $document.find('body')[0];
						this.count = 0;

            // Compile the directive
            this.progressbarEl = $compile('<ng-progress></ng-progress>')(this.$scope);
            // Add the element to body
            this.parent.appendChild(this.progressbarEl[0]);
            // Set the initial height
            this.$scope.count = this.count;
            // If height or color isn't undefined, set the height, background-color and color.
            if (this.height !== undefined) {
                this.progressbarEl.eq(0).children().css('height', this.height);
            }
            if (this.color !== undefined) {
                this.progressbarEl.eq(0).children().css('background-color', this.color);
                this.progressbarEl.eq(0).children().css('color', this.color);
            }
            // The ID for the interval controlling start()
            this.intervalCounterId = 0;

                // Starts the animation and adds between 0 - 5 percent to loading
                // each 400 milliseconds. Should always be finished with progressbar.complete()
                // to hide it
                this.start = function () {
                    // TODO Use requestAnimationFrame instead of setInterval
                    // https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame
                    this.show();
                    var self = this;
                    clearInterval(this.intervalCounterId);
                    this.intervalCounterId = setInterval(function () {
                        if (isNaN(self.count)) {
                            clearInterval(self.intervalCounterId);
                            self.count = 0;
                            self.hide();
                        } else {
                            self.remaining = 100 - self.count;
                            self.count = self.count + (0.15 * Math.pow(1 - Math.sqrt(self.remaining), 2));
                            self.updateCount(self.count);
                        }
                    }, 200);
                };
                this.updateCount = function (new_count) {
                    this.$scope.count = new_count;
                    if(!this.$scope.$$phase) {
                        this.$scope.$apply();
                    }
                };
                // Sets the height of the progressbar. Use any valid CSS value
                // Eg '10px', '1em' or '1%'
                this.setHeight = function (new_height) {
                    if (new_height !== undefined) {
                        this.height = new_height;
                        this.$scope.height = this.height;
                        if(!this.$scope.$$phase) {
                            this.$scope.$apply();
                        }
                    }
                    return this.height;
                };
                // Sets the color of the progressbar and it's shadow. Use any valid HTML
                // color
                this.setColor = function(new_color) {
                    if (new_color !== undefined) {
                        this.color = new_color;
                        this.$scope.color = this.color;
                        if(!this.$scope.$$phase) {
                            this.$scope.$apply();
                        }
                    }
                    return this.color;
                };
                this.hide = function() {
                    this.progressbarEl.children().css('opacity', '0');
                    var self = this;
                    self.animate(function () {
                        self.progressbarEl.children().css('width', '0%');
                        self.animate(function () {
                            self.show();
                        }, 500);
                    }, 500);
                };
                this.show = function () {
                    var self = this;
                    self.animate(function () {
                        self.progressbarEl.children().css('opacity', '1');
                    }, 100);
                };
                // Cancel any prior animations before running new ones.
                // Multiple simultaneous animations just look weird.
                this.animate = function(fn, time) {
                    if(this.animation !== undefined) { $timeout.cancel(this.animation); }
                    this.animation = $timeout(fn, time);
                };
                // Returns on how many percent the progressbar is at. Should'nt be needed
                this.status = function () {
                    return this.count;
                };
                // Stops the progressbar at it's current location
                this.stop = function () {
                    clearInterval(this.intervalCounterId);
                };
                // Set's the progressbar percentage. Use a number between 0 - 100.
                // If 100 is provided, complete will be called.
                this.set = function (new_count) {
                    this.show();
                    this.updateCount(new_count);
                    this.count = new_count;
                    clearInterval(this.intervalCounterId);
                    return this.count;
                };
                this.css = function (args) {
                    return this.progressbarEl.children().css(args);
                };
                // Resets the progressbar to percetage 0 and therefore will be hided after
                // it's rollbacked
                this.reset = function () {
                    clearInterval(this.intervalCounterId);
                    this.count = 0;
                    this.updateCount(this.count);
                    return 0;
                };
                // Jumps to 100% progress and fades away progressbar.
                this.complete = function () {
                    this.count = 100;
                    this.updateCount(this.count);
                    var self = this;
                    clearInterval(this.intervalCounterId);
                    $timeout(function () {
                        self.hide();
                        $timeout(function () {
                            self.count = 0;
                            self.updateCount(self.count);
                        }, 500);
                    }, 1000);
                    return this.count;
                };
                // Set the parent of the directive, sometimes body is not sufficient
                this.setParent = function(newParent) {
                    if(newParent === null || newParent === undefined) {
                        throw new Error('Provide a valid parent of type HTMLElement');
                    }

                    if(this.parent !== null && this.parent !== undefined) {
                        this.parent.removeChild(this.progressbarEl[0]);
                    }

                    this.parent = newParent;
                    this.parent.appendChild(this.progressbarEl[0]);
                };
                // Gets the current element the progressbar is attached to
                this.getDomElement = function () {
                    return this.progressbarEl;
                };
                this.setAbsolute = function() {
                    this.progressbarEl.css('position', 'absolute');
                };
            }];
    })
.factory('ngProgressFactory', ['$injector', 'ngProgress', function($injector, ngProgress) {
    var service = {
        createInstance: function () {
            return $injector.instantiate(ngProgress);
        }
    };
    return service;
}]);
angular.module('ngProgress.directive', [])
    .directive('ngProgress', ["$window", "$rootScope", function ($window, $rootScope) {
        var directiveObj = {
            // Replace the directive
            replace: true,
            // Only use as a element
            restrict: 'E',
            link: function ($scope, $element, $attrs, $controller) {
                // Watch the count on the $rootScope. As soon as count changes to something that
                // isn't undefined or null, change the counter on $scope and also the width of
                // the progressbar. The same goes for color and height on the $rootScope
                $scope.$watch('count', function (newVal) {
                    if (newVal !== undefined || newVal !== null) {
                        $scope.counter = newVal;
                        $element.eq(0).children().css('width', newVal + '%');
                    }
                });
                $scope.$watch('color', function (newVal) {
                    if (newVal !== undefined || newVal !== null) {
                        $scope.color = newVal;
                        $element.eq(0).children().css('background-color', newVal);
                        $element.eq(0).children().css('color', newVal);
                    }
                });
                $scope.$watch('height', function (newVal) {
                    if (newVal !== undefined || newVal !== null) {
                        $scope.height = newVal;
                        $element.eq(0).children().css('height', newVal);
                    }
                });
            },
            // The actual html that will be used
            template: '<div id="ngProgress-container"><div id="ngProgress"></div></div>'
        };
        return directiveObj;
    }]);

angular.module('ngProgress', ['ngProgress.directive', 'ngProgress.provider']);
'use strict';

/*
 * AngularJS Toaster
 * Version: 0.4.4
 *
 * Copyright 2013 Jiri Kavulak.  
 * All Rights Reserved.  
 * Use, reproduction, distribution, and modification of this code is subject to the terms and 
 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
 *
 * Author: Jiri Kavulak
 * Related to project of John Papa and Hans FjÃ¤llemark
 */

angular.module('toaster', ['ngAnimate'])
.service('toaster', ['$rootScope', function ($rootScope) {
    this.pop = function (type, title, body, timeout, bodyOutputType) {
        this.toast = {
            type: type,
            title: title,
            body: body,
            timeout: timeout,
            bodyOutputType: bodyOutputType
        };
        $rootScope.$broadcast('toaster-newToast');
    };
	this.popSimple = function(type, title, body, timeout){
        this.pop(type, title, body, timeout, 'trustedHtml');
	}

    this.clear = function () {
        $rootScope.$broadcast('toaster-clearToasts');
    };
}])
.constant('toasterConfig', {
    'limit': 0,                   // limits max number of toasts 
    'tap-to-dismiss': true,
    'newest-on-top': true,
    //'fade-in': 1000,            // done in css
    //'on-fade-in': undefined,    // not implemented
    //'fade-out': 1000,           // done in css
    // 'on-fade-out': undefined,  // not implemented
    //'extended-time-out': 1000,    // not implemented
    'time-out': 5000, // Set timeOut and extendedTimeout to 0 to make it sticky
    'icon-classes': {
        error: 'toast-error',
        info: 'toast-info',
        success: 'toast-success',
        warning: 'toast-warning'
    },
    'body-output-type': '', // Options: '', 'trustedHtml', 'template'
    'body-template': 'toasterBodyTmpl.html',
    'icon-class': 'toast-info',
    'position-class': 'toast-top-right',
    'title-class': 'toast-title',
    'message-class': 'toast-message'
})
.directive('toasterContainer', ['$compile', '$timeout', '$sce', 'toasterConfig', 'toaster',
function ($compile, $timeout, $sce, toasterConfig, toaster) {
    return {
        replace: true,
        restrict: 'EA',
        link: function (scope, elm, attrs) {

            var id = 0;

            var mergedConfig = toasterConfig;
            if (attrs.toasterOptions) {
                angular.extend(mergedConfig, scope.$eval(attrs.toasterOptions));
            }

            scope.config = {
                position: mergedConfig['position-class'],
                title: mergedConfig['title-class'],
                message: mergedConfig['message-class'],
                tap: mergedConfig['tap-to-dismiss']
            };

            scope.configureTimer = function configureTimer(toast) {
                var timeout = typeof (toast.timeout) == "number" ? toast.timeout : mergedConfig['time-out'];
                if (timeout > 0)
                    setTimeout(toast, timeout);
            };

            function addToast(toast) {
                toast.type = mergedConfig['icon-classes'][toast.type];
                if (!toast.type)
                    toast.type = mergedConfig['icon-class'];

                id++;
                angular.extend(toast, { id: id });

                // Set the toast.bodyOutputType to the default if it isn't set
                toast.bodyOutputType = toast.bodyOutputType || mergedConfig['body-output-type']
                switch (toast.bodyOutputType) {
                    case 'trustedHtml':
                        toast.html = $sce.trustAsHtml(toast.body);
                        break;
                    case 'template':
                        toast.bodyTemplate = toast.body || mergedConfig['body-template'];
                        break;
                }

                scope.configureTimer(toast);

                if (mergedConfig['newest-on-top'] === true) {
                    scope.toasters.unshift(toast);
                    if (mergedConfig['limit'] > 0 && scope.toasters.length > mergedConfig['limit']) {
                        scope.toasters.pop();
                    }
                } else {
                    scope.toasters.push(toast);
                    if (mergedConfig['limit'] > 0 && scope.toasters.length > mergedConfig['limit']) {
                        scope.toasters.shift();
                    }
                }
            }

            function setTimeout(toast, time) {
                toast.timeout = $timeout(function () {
                    scope.removeToast(toast.id);
                }, time);
            }

            scope.toasters = [];
            scope.$on('toaster-newToast', function () {
                addToast(toaster.toast);
            });

            scope.$on('toaster-clearToasts', function () {
                scope.toasters.splice(0, scope.toasters.length);
            });
        },
        controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {

            $scope.stopTimer = function (toast) {
                if (toast.timeout) {
                    $timeout.cancel(toast.timeout);
                    toast.timeout = null;
                }
            };

            $scope.restartTimer = function (toast) {
                if (!toast.timeout)
                    $scope.configureTimer(toast);
            };

            $scope.removeToast = function (id) {
                var i = 0;
                for (i; i < $scope.toasters.length; i++) {
                    if ($scope.toasters[i].id === id)
                        break;
                }
                $scope.toasters.splice(i, 1);
            };

            $scope.remove = function (id) {
                if ($scope.config.tap === true) {
                    $scope.removeToast(id);
                }
            };
        }],
        template:
        '<div  id="toast-container" ng-class="config.position">' +
            '<div ng-repeat="toaster in toasters" class="toast" ng-class="toaster.type" ng-click="remove(toaster.id)" ng-mouseover="stopTimer(toaster)"  ng-mouseout="restartTimer(toaster)">' +
              '<div ng-class="config.title">{{toaster.title}}</div>' +
              '<div ng-class="config.message" ng-switch on="toaster.bodyOutputType">' +
                '<div ng-switch-when="trustedHtml" ng-bind-html="toaster.html"></div>' +
                '<div ng-switch-when="template"><div ng-include="toaster.bodyTemplate"></div></div>' +
                '<div ng-switch-default >{{toaster.body}}</div>' +
              '</div>' +
            '</div>' +
        '</div>'
    };
}]);

(function() {
    angular.module('logtable', ['ngTable'])

    .directive('logtable', function() {
        return {
            restrict: 'E',
            templateUrl: 'partials/logtable.html',
			link: function (scope, element, attrs) {
				
			},
			controller: ['$scope','$rootScope','NgTableParams', '$filter', '$timeout', function($scope, $rootScope, NgTableParams, $filter, $timeout) {	
				$scope.total = {};
			    
				$scope.filters = {
		            package: '',
					level: '',
					miliseconds: '',
					timestamp: '',
					thread: '',
					class: '',
					method: '',
					message: '',
					exception: ''
	        	};
				
				$scope.pagination = {};
				$scope.pagination.currentPage = 1;
				$scope.pagination.perPage = 40;

				/*
				function testRow(){
					var xml = '<record reset="true">  <package>mytestrow!!!!</package>  <level>SEVERE</level>  <miliseconds>1473163518955</miliseconds>  <timestamp>09/06/2016 13:05:18:956</timestamp>  <thread>0</thread>  <class>Connection</class>  <method>newSocket</method>  <message>Operation timed out (com.microstrategy.webapi.MSTRWebAPIException)</message>  <exception>cthisismytestrow</exception></record>';

					var xml = "<xml>" + xml +"</xml>";
					var x2js = new X2JS();
				
					var json = x2js.xml_str2json(xml);
				
					console.log("length: ",json.xml.length);
				
					if(json.xml.record.length){
						console.log(json.xml.record.length + " rows");
						for(var ii = 0;ii< json.xml.record.length;ii++){
							$rootScope.data.push(json.xml.record[ii]);
						}
					}else{
						console.log("1 row");
						$rootScope.data.push(json.xml.record)
					}
				}
				testRow();
				//*/
				console.log("using data: ",$rootScope.data);

			    $scope.tableParams = new NgTableParams({
			        page: $scope.pagination.currentPage,            // show first page
			        count: $scope.pagination.perPage,           // count per page
			        sorting: { 
			            package: '',
						level: '',
						miliseconds: '',
						timestamp: 'desc',
						thread: '',
						class: '',
						method: '',
						message: '',
						exception: ''
					},
			        filter: $scope.filters,
			    }, 
				{
			        //filterSwitch: true,
			        //total: 0, // length of data
					filterOptions: {
						filterDelay: 200
					},
					dataset: $rootScope.data
				});
				
				$rootScope.$watch('data', function () {
					//debugger;
					$timeout(function(){
						$scope.tableParams.settings({
							dataset: $rootScope.data
						});
						//debugger;
					}, 200)
					
					
				});
				
			}],
			controllerAs: 'logtableCtrl'
        };
    });
})();
(function() {
    angular.module('mainform', ['ngFileUpload'])

    // directives make HTML easier, pull in subfiles without much effort.
    // <product-title></>
    .directive('mainform', function() {
        return {
            restrict: 'E',
            templateUrl: 'partials/mainform.html',
			/*
			link: function (scope, element, attrs) {
				scope.uploadButton = element[0].getElementsByClassName("uploadButton")[0];
				scope.uploadButton.onchange = function(e) {
					scope.uploadXmlFile(e);
				};
			},//*/
			controller: ['$scope','$rootScope', function($scope, $rootScope) {
			
				$scope.uploadXmlFile = function(files){
					if(!files) return;

					$rootScope.data = new Array();
					$rootScope.index = 0;
					console.clear();
					
			        if (files && files.length) {
						$scope.log = "Processing " + files.length + " files.";
						
			            for (var i = 0; i < files.length; i++) {
			                var file = files[i];
							
							reader = new FileReader();
							reader.onloadend = function(e){
								//debugger;
								$scope.log = "Loaded " + i + "/" + files.length + " files.";
								
								var xml = "<xml>" + e.target.result +"</xml>";
								var x2js = new X2JS();
								
								var json = x2js.xml_str2json(xml);
								
								console.log("length: ",json.xml.length);
								
								if(json.xml.record.length){
									console.log(json.xml.record.length + " rows");
									
									for(var ii = 0;ii< json.xml.record.length;ii++){										
										json.xml.record[ii].id = $rootScope.index;
										$rootScope.data.push(json.xml.record[ii]);
										$rootScope.index++;
										
									}
									
								}else{
									console.log("1 row");
									
									json.xml.record.id = $rootScope.index;
									$rootScope.data.push(json.xml.record)
									$rootScope.index++;
								}
								
							  	
						  		console.log("loaded: ", $rootScope.data);
								console.log("have this many results: ", $rootScope.data.length)
								
								
							};
					
							reader.readAsBinaryString(file);
						}
						
					}
					

				};
				
				$scope.$watch('files', function () {
					$scope.uploadXmlFile($scope.files);
			    });
				
				$scope.$watch('file', function () {
					if ($scope.file != null) {
					    $scope.files = [$scope.file]; 
					}
				});
				$scope.log = '';
				
			    
			}],
			controllerAs: 'mainformCtrl'
        };
    });
})();
(function() {
    angular.module('sidebar', [])

    // directives make HTML easier, pull in subfiles without much effort.
    // <product-title></>
    .directive('sidebar', function() {
        return {
            restrict: 'E',
            templateUrl: 'partials/sidebar.html',
			link: function (scope, element, attrs) {
				
			},
			controller: ['$scope', function($scope) {				
				
			    $scope.doLogin = function (form) {
					
				};
				
				
			}],
			controllerAs: 'sidebarCtrl'
        };
    });
})();
(function() {
    angular.module('Data', ['ngProgress'])
	.factory("Data", ['$http', 'ngProgressFactory', '$rootScope', '$q',
		function ($http, ngProgressFactory, $rootScope, $q) {
			
			
			var timestamp = new Date().getTime();
			timestamp = '?&i='+timestamp;
			var progressBar = ngProgressFactory.createInstance();
			//progressBar.setParent(document.getElementById('main-container'));
			progressBar.queue = 0;
			progressBar.updateQueue = function(value){
				var startedNow = true;
				if(progressBar.queue == 0) startedNow = false;
				//debugger;
				progressBar.queue = progressBar.queue + value;
				
				if(progressBar.queue > 0) {
					if(!startedNow) {
						progressBar.start();
					}
					else{
						if(progressBar.queue != 1){
							var newVal = (100 / progressBar.queue);
							progressBar.set(newVal);
							progressBar.start();
						}
					}
				}
				else{
					progressBar.complete();
				}
			}
			
		    var obj = {};
		    var serviceBase = 'API/';
			obj.handleError = function(e){
				//debugger;
				if(typeof(e.data) != 'undefined' && e.data){
					console.log("POST failed",e);
					console.log(e.data.status + " : " + e.data.message + " : " + e.data.cause);
					$rootScope.hasError = true;
					$rootScope.error = {
						status: e.data.status,
						message: e.data.message,
						cause: e.data.cause
					}; 
				}else{
					//don't think this will ever hit, unless server is unreachable?
					$rootScope.hasError = true;
					$rootScope.error = {
						status: -1,
						message: "uncaught exception",
						cause: "check that the URL is correct and that the server is reachable."
					}; 
				}
			};
		    obj.get = function (url, headers, params) {
				//debugger;
				progressBar.updateQueue(1);
				return $http({
		            method: 'GET',
				    headers: headers,
					url: url + params
				}).catch(function(e){
					obj.handleError(e);
				}).then(function (results) {
					progressBar.updateQueue(-1);
					console.log("post results: ",results);
					
					if(typeof results == 'undefined'){
						return $rootScope.error;
					}
					return results;
					
		        });
		    };
		    obj.post = function (url, postBody, headers) {	
				progressBar.updateQueue(1);
				return $http({
		            method: 'POST',
				    headers: headers,
					url: url,
					data: postBody 
				}).catch(function(e){
					console.log("POST failure", e);
					obj.handleError(e);
				}).then(function (results) {
					progressBar.updateQueue(-1);
					console.log("post results: ",results);
					
					if(typeof results == 'undefined'){
						return $rootScope.error;
					}
					return results;
					
		        });
		    };
		    obj.delete = function (url, headers) {	
				//debugger;
				progressBar.updateQueue(1);
				return $http({
		            method: 'DELETE',
				    headers: headers,
					url: url
				}).then(function (results) {
					progressBar.updateQueue(-1);
					
					console.log("DELETE results: ");
					console.log(results);
					return results;
		        });
		    };
		    obj.put = function (q, object) {
		        return $http.put(serviceBase + q, object).then(function (results) {
					console.log("put: " + JSON.stringify(results.data));
					
		            return results.data;
		        });
		    };
		    return obj;
		}
	])
	
})();